/*--------------------------------------------------------------------------------
* Copyright (c) 2017,西北农林科技大学信息学院计算机科学系
* All rights reserved.
*
* 文件名称：main.c
* 文件标识：见配置管理计划书
* 摘要：黑色星期五求解的演示代码。
* 题目描述：
* 13号又是星期五是一个不寻常的日子吗?
* 13号在星期五比在其他日少吗?
* 为了回答这个问题,写一个程序来计算在n年里13日落在星期一,星期二……星期日的次数.
* 这个测试从1900年1月1日到1900+n-1年12月31日.
* n是一个非负数且不大于400.
* 这里有一些你要知道的:
*       1900年1月1日是星期一.
*       4,6,11和9月有30天.其他月份除了2月有31天.闰年2月有29天,平年2月有28天.
*       年份可以被4整除的为闰年(1992=4*498 所以 1992年是闰年,但是1990年不是闰年)
*       以上规则不适合于世纪年.可以被400整除的世纪年为闰年,否则为平年.所以,
*       1700,1800,1900和2100年是平年,而2000年是闰年.
*   输入:
*        一个整数n。
*   输出:
*       七个在一行且相分开的整数,它们代表13日是星期六,星期日,星期一…..星期五的次数。
* 样例输入:
*       20
* 样例输出:
*       36 33 34 33 35 35 34
*
* 当前版本：1.0
* 作者：耿楠
* 完成日期：2018年11月21日
*
* 取代版本：无
* 原作者：
* 完成日期：
--------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 函数原型
int IsLeapYear(int); // 判断是不是闰年
int GetMonthDays(int, int); // 返回1个月的天数
int GetMonthDaysByArr(int, int); // 通过一维数组操作返回1个月的天数
int GetMonthDaysBy2DArr(int, int); // 通过二维数组操作返回1个月的天数

void GetAnsEnumDays(int *, int); // 按天枚举法求解
void GetAnsEnumWeeks(int *, int); // 按周枚举法求解
void GetAnsKimLarsson(int *, int); // 按基姆拉尔森日期公式求解

void OutAns(int *, int); // 输出结果

int main()
{
    int n;
    int ans[7] = {0}; // 结果数组，注意初始化为0

    //scanf("%d", &n);
    n = 20;

    // 按周枚举求解
    printf("Get answer by enum days.\n");
    memset(ans, 0, sizeof(ans)); // 结果数据清0
    GetAnsEnumDays(ans, n);
    // 输出结果
    OutAns(ans, 7);
    printf("\n");

    // 按周枚举求解
    printf("Get answer by enum week.\n");
    memset(ans, 0, sizeof(ans)); // 结果数据清0
    GetAnsEnumWeeks(ans, n);
    // 输出结果
    OutAns(ans, 7);
    printf("\n");

    // 按基姆拉尔森日期公式求解
    printf("Get answer by Kim larsson calculation formula.\n");
    memset(ans, 0, sizeof(ans)); // 结果数据清0
    GetAnsKimLarsson(ans, n);
    // 输出结果
    OutAns(ans, 7);
    printf("\n");

    return 0;
}

// 函数定义

//-----------------------------------------------------------------------------------------------
// 名称: void OutAns(int *pa, int n)
// 功能: 输出计算结果
// 参数:
//      [int *pa] --- 结果数组指针
//      [int n] --- 结果数组长度
// 返回: [void]  --- 无
// 作者: 耿楠
// 日期: 2018年11月21日
//-----------------------------------------------------------------------------------------------
void OutAns(int *pa, int n)
{
    // 先输出周六，周日
    printf("%d %d ", pa[n - 1], pa[0]);

    // 再输出周一到周五
    for(int i = 1; i <= n - 2; i++)
    {
        printf("%d ", pa[i]);
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: int IsLeapYear(int y)
// 功能: 判断指定的年是不是闰年
// 参数:
//      [int y] --- 要判断的年份
// 返回: [int]  --- 返回判断结果，1表示是闰年，0表示不是闰年
// 作者: 耿楠
// 日期: 2018年11月21日
//-----------------------------------------------------------------------------------------------
int IsLeapYear(int y)
{
    if((y % 4 == 0 && y % 100 != 0) || (y % 400 == 0))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetMonthDays(int y, int m)
// 功能: 返回1个月的天数
// 算法: 通过switch进行判断，然后返回
// 参数:
//      [int y] --- 年份
//      [int m] --- 月份
// 返回: [int]  --- 返回一个月的天数
// 作者: 耿楠
// 日期: 2018年11月21日
//-----------------------------------------------------------------------------------------------
int GetMonthDays(int y, int m)
{
    int days;
    switch(m)
    {
    case 4:
    case 6:
    case 9:
    case 11:
        days = 30;
        break;
    case 2:
        if(IsLeapYear(y))
        {
            days = 29;
        }
        else
        {
            days = 28;
        }
        break;
    default:
        days = 31;
        break;
    }

    return days;
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetMonthDaysByArr(int y, int m)
// 功能: 返回1个月的天数
// 算法: 将每月的天数存入一维数组，利用月份作为下标进行提取，只对2月份做特殊处理
// 参数:
//      [int y] --- 年份
//      [int m] --- 月份
// 返回: [int]  --- 返回一个月的天数
// 作者: 耿楠
// 日期: 2018年11月21日
//-----------------------------------------------------------------------------------------------
int GetMonthDaysByArr(int y, int m)
{
    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    if(m != 2)
    {
        return days[m - 1];
    }
    else
    {
        if(IsLeapYear(y))
        {
            return days[m - 1] + 1;
        }
        else
        {
            return days[m - 1];
        }
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetMonthDaysBy2DArr(int y, int m)
// 功能: 返回1个月的天数
// 算法: 将每月的天数存入二维数组，第1维是闰年信息，第2维是对应月份的天数，用下标处理。
// 参数:
//      [int y] --- 年份
//      [int m] --- 月份
// 返回: [int]  --- 返回一个月的天数
// 作者: 耿楠
// 日期: 2018年11月21日
//-----------------------------------------------------------------------------------------------
int GetMonthDaysBy2DArr(int y, int m)
{
    int days[2][12] = {{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
        {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
    };

    int idx = y % 400 == 0 || (y % 4 == 0 && y % 100 != 0) ? 1 : 0;

    return days[idx][m - 1];
}

//-----------------------------------------------------------------------------------------------
// 名称: void GetAnsEnumDays(int *pa, int n)
// 功能: 按天累计进行枚举，求解13日落入周几的次数
// 算法: 对每个月的日期与7求余则得到当前天的是周几，用其作为下标，当天数是13时
//          对pa对应的下标元素加1进行计数。
// 参数:
//      [int *pa] --- 存储计算结果的数组的指针
//      [int n] --- 要计算的从1900年后的年数
// 返回: [int]  --- 返回一个月的天数
// 作者: 耿楠
// 日期: 2018年11月21日
//-----------------------------------------------------------------------------------------------
void GetAnsEnumDays(int *pa, int n)
{
    int i,  j, d, m;

    unsigned int w = 0; // 周内第周几累加器

    for(i = 1900; i <= 1900 + n - 1; i++) // 年循环
    {
        for(j = 1; j <= 12; j++) // 月循环
        {
            m = GetMonthDaysBy2DArr(i, j); // 当月天数
            for(d = 1; d <= m; d++ )
            {
                w++; // 周几？
                w %= 7; // 求余
                if(d == 13) // 13号
                {
                    pa[w]++;
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: void GetAnsEnumWeeks(int *pa, int n)
// 功能: 按周枚举法求解，求解13日落入周几的次数
// 算法: 根据第1个13日是周6的特点，累加每个月的天数7求余则得到当前月当13日是周几，
//          用其作为下标，对pa对应的下标元素加1进行计数。
// 参数:
//      [int *pa] --- 存储计算结果的数组的指针
//      [int n] --- 要计算的从1900年后的年数
// 返回: [int]  --- 返回一个月的天数
// 作者: 耿楠
// 日期: 2018年11月21日
//-----------------------------------------------------------------------------------------------
void GetAnsEnumWeeks(int *pa, int n)
{
    int i, j;
    int w = 6; // 第1个13日是周6

    for(i = 1900; i <= 1900 + n - 1; i++) // 年循环
    {
        for(j = 1; j <= 12; j++) // 月循环
        {
            pa[w % 7]++; // 求余做下标，累加
            w += GetMonthDaysByArr(i, j); // 下到下一个月
        }
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: void GetAnsKimLarsson(int *pa, int n)
// 功能: 按基姆拉尔森日期公式求解，求解13日落入周几的次数
// 算法: 基姆拉尔森计算公式：W = (d+2*m+3*(m+1)/5+(y)+(y)/4-(y)/100+(y)/400)%7;
//          在公式中d表示日期中的日数+1，m表示月份数，y表示年份。
//          用计算出的W作为下标，对pa对应的下标元素加1进行计数。
//          需要注意的是用该公式时，需要把一月和二月看成是上一年的十三月和十四月，
//          公式中的d是日期加1，所以计算结果就是实际的星期，
//          即是：“1”为星期一，“2”为星期二......“0”为星期日。
// 参数:
//      [int *pa] --- 存储计算结果的数组的指针
//      [int n] --- 要计算的从1900年后的年数
// 返回: [int]  --- 返回一个月的天数
// 作者: 耿楠
// 日期: 2018年11月21日
//-----------------------------------------------------------------------------------------------
void GetAnsKimLarsson(int *pa, int n)
{
    int i, j;

    for(i = 1900; i <= 1900 + n - 1; i++) // 年循环
    {
        for(j = 1; j <= 12; j++) // 月循环
        {
            int m, w; // 内部变量
            if(j == 1 || j == 2) // 1月和2月，需要按前一年的13、14月来计算
            {
                m = j + 12;
                w = (14 + 2 * m + 3 * (m + 1) / 5 + (i - 1) + (i - 1) / 4 - (i - 1) / 100 + (i - 1) / 400) % 7; // 基姆拉尔森计算公式
            }
            else
            {
                m = j;
                w = (14 + 2 * m + 3 * (m + 1) / 5 + (i) + (i) / 4 - (i) / 100 + (i) / 400) % 7; // 基姆拉尔森计算公式
            }
            pa[w]++;
        }
    }
}
