/*--------------------------------------------------------------------------------
* Copyright (c) 2017,西北农林科技大学信息学院计算机科学系
* All rights reserved.
*
* 文件名称：main.c
* 文件标识：见配置管理计划书
* 摘要：求数字特征值的演示代码。
* 题目描述：对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。
*         对于一个整数，从个位开始对每一位数字编号，个位是1号，
*         十位是2号，以此类推。这个整数在第n位上的数字记作x，
*         如果x和n的奇偶性相同，则记下一个1，否则记下一个0。
*         按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，
*         就形成了一个二进制数字。比如，对于342315，
*         这个二进制数字就是001101，其计算过程可以表示为：
*         -------------------------------------
*         |各位数字 | 3 | 4  | 2 | 3  | 1 | 5  |
*         |数位顺序 | 6 | 5  | 4 | 3  | 2 | 1  |
*         |数字奇偶 | 奇 | 偶 |偶 | 奇 | 奇 | 奇 |
*         |数位奇偶 | 偶 | 奇 |偶 | 奇 | 偶 | 奇 |
*         |奇偶一致 | 0 |  0 | 1 | 1  | 0  | 1 |
*         |进制权值 | 32| 16 | 8 | 4  | 2  | 1 |
*         -------------------------------------
*         程序要读入一个非负整数，整数的范围是[0,1000000]，
*         然后按照上述算法计算出表示奇偶性的那个二进制数字，
*         输出它对应的十进制值。
*         提示：将整数从右向左分解，数位每次加1，而二进制值每次乘2。
*
* 输入格式：一个非负整数，整数的范围是[0,1000000]。
*
* 输出格式：一个整数，表示计算结果。
*
* 输入样例：
*          342315
*
* 输出样例：
*          13
*
* 当前版本：1.0
* 作者：耿楠
* 完成日期：2018年12月11日
*
* 取代版本：无
* 原作者：
* 完成日期：
--------------------------------------------------------------------------------*/
#include<stdio.h>
#include<string.h>
//#include<math.h>

#define MAXDIGIT  7

// 函数原型
int GetXNORWithIF(int, int); // 通过判断获得两个数字的奇偶性同或结果
int GetXNORWithBit(int, int); // 通过位运算获得两个数字的奇偶性同或结果
int GetXNORWithAddBit(int, int); // 通过加法及位运算获得两个数字的奇偶性同或结果
int GetEigenValWithItr(unsigned int); // 直接计算获得数字的特征值
int GetEigenValWithLUT(unsigned int); // 通过查找表获得数字的特征值
int GetEigenValWithBit(unsigned int); // 通过位运算获得数字的特征值
int GetEigenValWithStr(unsigned int); // 通过先转换成数字字符串再计算特征值

void run(void); // 测试函数

// 函数类型重定义
typedef int(*xnorF)(int, int);
typedef int(*eigF)(unsigned int);

// 函数描述结构体
typedef struct
{
    char *msg; //
    xnorF pfoo;
} xnorT;

typedef struct
{
    char *msg; //
    eigF pfoo;
} eigT;

// 测试
int main()
{

    run();

    return 1;
}

// 函数定义

//-----------------------------------------------------------------------------------------------
// 名称: void run(void)
// 功能: 函数功能测试函数
// 算法: 利用带有NULL的函数指针数组和数组名称指针数组通过循环测试每个函数。
//          若有新函数，将相应名称加入数组即可。
// 参数:
//       [void] --- 无
// 返回: [void]  --- 无
// 作者: 耿楠
// 日期: 2018年12月20日
//-----------------------------------------------------------------------------------------------
void run(void)
{
    // 测试同或计算函数
    xnorT xnorItem[] =
    {
        {"With it", GetXNORWithIF},
        {"With bit", GetXNORWithBit},
        {"With add&bit", GetXNORWithAddBit}
    };
    int xnord[][2] = {{6, 3}, {6, 4}, {5, 3}, {7, 4}};
    printf("XNOR Testing...\n");
    for(int i = 0; i < sizeof(xnorItem) / sizeof(xnorItem[0]); i++)
    {
        printf("%02d. %s: \n", i + 1, xnorItem[i].msg);

        for(int j = 0; j < sizeof(xnord) / sizeof(xnord[0]); j++)
        {
            int res = xnorItem[i].pfoo(xnord[j][0], xnord[j][1]);
            printf("XNOR(%d, %d) = %d\n", xnord[j][0], xnord[j][1], res);
        }
        printf("\n");
    }

    // 测试数字特征值计算函数
    eigT eigItem[] =
    {
        {"With itr", GetEigenValWithItr},
        {"With LUT", GetEigenValWithLUT},
        {"With Bit", GetEigenValWithBit},
        {"With str&bit", GetEigenValWithStr}
    };

    int eigd[] = {342315, 12345, 234, 876399};
    printf("EigenVal Testing...\n");
    for(int i = 0; i < sizeof(eigItem) / sizeof(eigItem[0]); i++)
    {
        printf("%02d. %s: \n", i + 1, eigItem[i].msg);

        for(int j = 0; j < sizeof(eigd) / sizeof(eigd[0]); j++)
        {
            int res = eigItem[i].pfoo(eigd[j]);
            printf("Eig(%d) = %d\n", eigd[j], res);
        }
        printf("\n");
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetXNORWithIF(int m, int n)
// 功能: 获得两个数字的奇偶性同或结果
// 算法: 通过分支结构进行判断
// 参数:
//       [int m] --- 第1个整数
//       [int n] --- 第2个整数
// 返回: [int]  --- 两个数字奇偶性相同返回1，不同返回0
// 作者: 耿楠
// 日期: 2018年12月12日
//-----------------------------------------------------------------------------------------------
int GetXNORWithIF(int m, int n)
{
    int odd_m = 0;
    int odd_n = 0;

    if(m % 2 == 1)
    {
        odd_m = 1;
    }

    if(n % 2 == 1)
    {
        odd_n = 1;
    }

    if(odd_m == odd_n)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetXNORWithBit(int m, int n)
// 功能: 获得两个数字的奇偶性同或结果
// 算法: 通过位运算实现，利用"& 0x01"判断是不是偶数，利用1-“异或”运算结果得到结果。
// 参数:
//       [int m] --- 第1个整数
//       [int n] --- 第2个整数
// 返回: [int]  --- 两个数字奇偶性相同返回1，不同返回0
// 作者: 耿楠
// 日期: 2018年12月12日
//-----------------------------------------------------------------------------------------------
int GetXNORWithBit(int m, int n)
{
    // 利用"& 0x01"判断是不是偶数
    return 1 - ((m & 0x01) ^ (n & 0x01));
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetXNORWithAddBit(int m, int n)
// 功能: 获得两个数字的奇偶性同或结果
// 算法: 奇数+奇数=偶数
//          偶数+偶数=偶数
//          奇数+偶数=奇数
//          当数字和序号奇偶性相同的时候，它们的和一定是偶数，
//          通过"& 0x01"判断是不是偶数
// 参数:
//       [int m] --- 第1个整数
//       [int n] --- 第2个整数
// 返回: [int]  --- 两个数字奇偶性相同返回1，不同返回0
// 作者: 耿楠
// 日期: 2018年12月12日
//-----------------------------------------------------------------------------------------------
int GetXNORWithAddBit(int m, int n)
{
    // 利用"& 0x01"判断是不是偶数
    return 1 - ((m + n) & 0x01);
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetEigenValWithItr(unsigned int n)
// 功能: 获得一个正整数的特征值
// 参数:
//       [unsigned int n] --- 要处理的正整数
// 返回: [int]  --- 一个正整数的特征值
// 作者: 耿楠
// 日期: 2018年12月12日
//-----------------------------------------------------------------------------------------------
int GetEigenValWithItr(unsigned int n)
{
    int d = 0; // 每次循环提取出的数字
    int c = 0; // 两个数字奇偶性同或结果
    int i = 1; // 位数
    int sum = 0; // 结果
    int r = 1; // 二进制位权重

    while (n != 0)
    {
        //提取出最某位的数字
        d = n % 10;

        // 获得奇偶性(调用分支判断函数实现)
        c = GetXNORWithIF(d, i);

        // 计算特征值
        sum += c * r;

        // 准备提取下一个数字
        i++;

        // 权重乘2
        r *= 2;

        // 去掉个位之后形成的新数字
        n /= 10;

    }

    return sum;
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetEigenValWithLUT(unsigned int n)
// 功能: 获得一个正整数的特征值
// 参数:
//       [unsigned int n] --- 要处理的正整数
// 返回: [int]  --- 一个正整数的特征值
// 作者: 耿楠
// 日期: 2018年12月12日
//-----------------------------------------------------------------------------------------------
int GetEigenValWithLUT(unsigned int n)
{
    int d = 0; // 每次循环提取出的数字
    int i = 0; // 两个数字奇偶性同或结果
    int j = 0; // 位数
    int sum = 0; // 结果

    // 二进制权重查找表(最多MAXDIGIT位)
    unsigned int bweight[2][MAXDIGIT] =
    {
        {0, 0, 0, 0, 0, 0, 0},
        {1, 2, 4, 8, 16, 32, 64}
    };

    while (n != 0)
    {
        //提取出最某位的数字
        d = n % 10;

        // 获得奇偶性(调用函数GetXNORWithBit实现)
        i = GetXNORWithAddBit(d, j + 1);

        // 计算特征值(通过查找表实现，避免计算)
        sum += bweight[i][j];

        // 准备提取下一个数字
        j++;

        // 去掉个位之后形成的新数字
        n /= 10;
    }
    return sum;
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetEigenValWithBit(unsigned int n)
// 功能: 获得一个正整数的特征值
// 算法: 主要任务由位运算实现
// 参数:
//       [unsigned int n] --- 要处理的正整数
// 返回: [int]  --- 一个正整数的特征值
// 作者: 耿楠
// 日期: 2018年12月12日
//-----------------------------------------------------------------------------------------------
int GetEigenValWithBit(unsigned int n)
{
    int d = 0; // 每次循环提取出的数字
    int i = 1; // 位数
    int sum = 0; // 结果
    int r = 1; // 二进制位权重

    // & 0xFFFFFFFF，用于判断是不是0
    while (n &  0xFFFFFFFF)
    {
        //提取出最某位的数字
        d = n % 10;

        // 计算特征值("& 0x01 == 0"表示是偶数)
        if(!((d & 0x01) ^ (i & 0x01)))
        {
            sum |= r; // 对应位置1，其它位不变
        }

        // 准备提取下一个数字
        i++;

        // 权重左移1位
        r <<= 1;

        // 去掉个位之后形成的新数字
        n /= 10;
    }

    return sum;
}

//-----------------------------------------------------------------------------------------------
// 名称: void ReverseStr(char *str, int left, int right)
// 功能: 对指定范围内的字符串进行逆序操作
// 算法: 分别从字符串的头和尾部向中间进发，依次交换头尾的值，直到在中间相遇。
// 参数:
//       [char *str] --- 要进行逆序的字符串指针
//       [int left] --- 起始位置
//       [int right] --- 结束位置
// 返回: [void]  --- 无
// 作者: 耿楠
// 日期: 2018年12月04日
// 注意: 这是一个辅助函数，其原型不应该出现在函数原型部分
//-----------------------------------------------------------------------------------------------
void ReverseStr(char *str, int left, int right)
{
    char tmp;
    while(left < right)
    {
        tmp = str[left];
        str[left++] = str[right];
        str[right--] = tmp;
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetEigenValWithStr(unsigned int n)
// 功能: 获得一个正整数的特征值
// 算法: 先将整数转成字符串，主要任务由位运算实现
// 参数:
//       [unsigned int n] --- 要处理的正整数
// 返回: [int]  --- 一个正整数的特征值
// 作者: 耿楠
// 日期: 2018年12月12日
//-----------------------------------------------------------------------------------------------
int GetEigenValWithStr(unsigned int n)
{
    char str[MAXDIGIT + 1]; // 数字字符串数组
    char *s = str;

    size_t len; // 字符串长度

    int d = 0; // 每次循环提取出的数字
    int i = 1; // 位数
    int sum = 0; // 结果
    int r = 1; // 二进制位权重

    // 调用sprintf将整数数字转换成字符串
    sprintf(str, "%d", n);
    len = strlen(str);
    ReverseStr(str, 0, len - 1); // 反转

    while(*s)
    {
        // 将数字字符的b6b5位置0
        // '0' 的二进制值是00110000
        // 0xCF二进制值是11001111
        // 相当于*s - '0';
        d = *s & 0xCF;

        // 计算特征值("& 0x01 == 0"表示是偶数)
        if(!((d & 0x01) ^ (i & 0x01)))
        {
            sum |= r; // 对应位置1，其它位不变
        }

        // 位数加1
        i++;

        // 权重左移1位
        r <<= 1;

        // 下1位
        s++;
    }

    return sum;
}
