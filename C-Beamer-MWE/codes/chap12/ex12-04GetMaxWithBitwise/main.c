/*--------------------------------------------------------------------------------
* Copyright (c) 2017,西北农林科技大学信息学院计算机科学系
* All rights reserved.
*
* 文件名称：main.c
* 文件标识：见配置管理计划书
* 摘要：利用位运算判断两个整数大小的演示代码。
*
* 当前版本：1.0
* 作者：耿楠
* 完成日期：2018年12月13日
*
* 取代版本：无
* 原作者：
* 完成日期：
--------------------------------------------------------------------------------*/
#include<stdio.h>
#include<string.h>

// 函数原型
int GetMaxWithIf(int, int); // 通过条件判断
int GetMaxWithBitwise(int, int); // 通过位操作返回最大数
int GetMinWithBitwise(int, int); // 通过位操作返回最小数

// 测试
int main()
{

    int m = 26, n = 367;

    printf("With If:\n");
    printf("Max(%d, %d) = %d\n", m, n, GetMaxWithIf(m, n));

    printf("\nWith Bitwise:\n");
    printf("Max(%d, %d) = %d\n", m, n, GetMaxWithBitwise(m, n));
    printf("Min(%d, %d) = %d\n", m, n, GetMinWithBitwise(m, n));

    return 1;
}

// 函数定义

//-----------------------------------------------------------------------------------------------
// 名称: int GetMaxWithIf(int m, int n)
// 功能: 返回两个整数中的大数
// 算法: 通过分支判断实现
// 参数:
//       [int m] --- 需要判断的一个整数
//       [int n] --- 需要判断的另一个整数
// 返回: [int]  --- 较大的数
// 作者: 耿楠
// 日期: 2018年12月13日
//-----------------------------------------------------------------------------------------------
int GetMaxWithIf(int m, int n)
{
    return m > n ? m : n;
}

//-----------------------------------------------------------------------------------------------
// 名称: int FilpZeroBit(int n)
// 功能: 反转一个整数的第0位
// 算法: 通过异或操作实现
// 参数:
//       [int n] --- 需要反转的整数
// 返回: [int]  --- 第0位反转后的结果
// 作者: 耿楠
// 日期: 2018年12月13日
// 注意: 这是一个辅助函数，可以不出现在函数原型列表中。
//-----------------------------------------------------------------------------------------------
int FilpZeroBit(int n)
{
    return n ^ 0X01;
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetSign(int n)
// 功能: 判断一个整数的正负
// 算法: 通过移位后判断符号位实现
// 参数:
//       [int n] --- 需要判断整数
// 返回: [int]  --- 正值返回1，负值返回0
// 作者: 耿楠
// 日期: 2018年12月13日
// 注意: 这是一个辅助函数，可以不出现在函数原型列表中。
//-----------------------------------------------------------------------------------------------
int GetSign(int n)
{
    size_t bits = 8 * sizeof(int); // 获得整数的位数
    bits--;
    return FilpZeroBit((n >> bits) & 0X01);
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetMaxWithBitwise(int m, int n)
// 功能: 返回最大数
// 算法: 通过位操作实现，通过正负符号来判断。
//         如果同号，m-n的符号可以作为判断条件，且不会溢出。
//         如果异号，通过表达式retm * m + retn * n的互斥特性，
//         必然有一个负数符号为0，就返回了另外一个数。
// 参数:
//       [int m] --- 需要判断的一个整数
//       [int n] --- 需要判断的另一个整数
// 返回: [int]  --- 较大的数
// 作者: 耿楠
// 日期: 2018年12月13日
//-----------------------------------------------------------------------------------------------
int GetMaxWithBitwise(int m, int n)
{
    int c = m - n; // 取得差值

    int sm = GetSign(m); // m的符号
    int sn = GetSign(n); // n的符号
    int sc = GetSign(c); // c的符号

    int sd = sm ^ sn; // 正负相同，结果为0，否则为1
    int ss = FilpZeroBit(sd);  // 正负相同1，否则为0

    // 1、如果m和n的不同号，取得的是m的符号
    // 2、如果m和n的同号，取得的是c的符号(m - n)
    int rm = ss * sc + sd * sm;
    // 取retm符号的反
    int rn = FilpZeroBit(rm);

    // 返回大值
    // 1、如果m和n的不同号，取得的是m的符号
    // 如果rm为1，则m为正，同时rn为0，则n为负，应该返回m
    // 如果rm为0，则m为负，同时rn为1，则n为正，应该返回n
    // 2、如果m和n的同号，取得的是c的符号(m - n)
    // 如果rm为1，则c为正，同时rn为0，m > n，应该返回m
    // 如果rm为0，则c为负，同时rn为1，m < n，应该返回n
    return rm * m + rn * n;
}

//-----------------------------------------------------------------------------------------------
// 名称: int GetMinWithBitwise(int m, int n)
// 功能: 返回最小数
// 算法: 通过位操作实现，通过正负符号来判断。
//         如果同号，m-n的符号可以作为判断条件，且不会溢出。
//         如果异号，通过表达式retm * m + retn * n的互斥特性，
//         必然有一个负数符号为0，就返回了另外一个数。
// 参数:
//       [int m] --- 需要判断的一个整数
//       [int n] --- 需要判断的另一个整数
// 返回: [int]  --- 较大的数
// 作者: 耿楠
// 日期: 2018年12月13日
//-----------------------------------------------------------------------------------------------
int GetMinWithBitwise(int m, int n)
{
    int c = m - n; // 取得差值

    int sm = GetSign(m); // m的符号
    int sn = GetSign(n); // n的符号
    int sc = GetSign(c); // c的符号

    int sd = sm ^ sn; // 正负相同，结果为0，否则为1
    int ss = FilpZeroBit(sd);  // 正负相同1，否则为0

    // 1、如果m和n的不同号，取得的是m的符号
    // 2、如果m和n的同号，取得的是c的符号(m - n)
    int rn = ss * sc + sd * sm;
    // 取retm符号的反
    int rm = FilpZeroBit(rn);

    // 返回小值
    // 1、如果m和n的不同号，取得的是m的符号
    // 如果rn为1，则m为正，同时rm为0，则n为负，应该返回n
    // 如果rn为0，则m为负，同时rm为1，则n为正，应该返回m
    // 2、如果m和n的同号，取得的是c的符号(m - n)
    // 如果rn为1，则c为正，同时rm为0，m > n，应该返回n
    // 如果rn为0，则c为负，同时rm为1，m < n，应该返回m
    return rm * m + rn * n;
}
