/*--------------------------------------------------------------------------------
* Copyright (c) 2017,西北农林科技大学信息学院计算机科学系
* All rights reserved.
*
* 文件名称：main.c
* 文件标识：见配置管理计划书
* 摘要：字符串循环右移的演示代码。
* 题目描述：一个长度为len的字符串，对其循环右移n位，如：
*                 char str[] = "abcdefg";
*                 右移3次后，变成"efgabcd"
*
* 当前版本：1.0
* 作者：耿楠
* 完成日期：2018年12月04日
*
* 取代版本：无
* 原作者：
* 完成日期：
--------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

// 函数原型
void PrintStr(char *); // 输出字符串
size_t GetStrLen(const char *); // 获得字符串长度
char *StrCpy(char *, const char *); // 字符串复制
void *MemCpy(void *, const void *, size_t); // 内存复制

void StrRshiftTest(); // 测试函数

void ReverseStr(char *, int, int); // 对指定范围内的字符串进行逆序操作
int RshiftStrMem(char *, int); // 利用内存移动实现循环右移位
int RshiftStrRev(char *, int); // 利用逆序实现循环右移位

// 测试
int main()
{
    StrRshiftTest();

    return 0;
}

// 函数定义

//-----------------------------------------------------------------------------------------------
// 名称: void StrRshiftTest()
// 功能: 测试函数输出字符串
// 参数:
//         无
// 返回: [void]  --- 无
// 作者: 耿楠
// 日期: 2018年12月04日
//-----------------------------------------------------------------------------------------------
void StrRshiftTest()
{
    char str[] = "abcdefg";
    char *s1, *s2;

    int len = GetStrLen(str);

    PrintStr(str);

    // 复制字符串
    s1 = malloc((len + 1) * sizeof(char));
    if(NULL == s1)
    {
        exit(1);
    }
    StrCpy(s1, str);

    s2 = malloc((len + 1) * sizeof(char));
    if(NULL == s2)
    {
        exit(1);
    }
    StrCpy(s2, str);

    // 循环右移3位
    RshiftStrMem(s1, 3);
    PrintStr(s1);

    // 循环右移2位
    RshiftStrRev(s2, 2);
    PrintStr(s2);

    // 释放内存
    free(s1);
    free(s2);
}

//-----------------------------------------------------------------------------------------------
// 名称: void PrintStr(char *str)
// 功能: 输出字符串
// 参数:
//         [char *str] --- 要输出的字符串的指针
// 返回: [void]  --- 无
// 作者: 耿楠
// 日期: 2018年12月04日
//-----------------------------------------------------------------------------------------------
void PrintStr(char *str)
{
    // 字符串为空，返回
    if (str == NULL)
    {
        return;
    }

    // 利用'\0'结束循环，输出每一个字符
    while(*str)
    {
        printf("%c", *str);
        str++;
    }

    // 输出换行
    printf("\n");
}

//-----------------------------------------------------------------------------------------------
// 名称: size_t GetStrLen(const char *str)
// 功能: 计算字符串长度
// 参数:
//         [char *str] --- 要输出的字符串的指针
// 返回: [size_t]  --- 无
// 作者: 耿楠
// 日期: 2018年12月04日
//-----------------------------------------------------------------------------------------------
size_t GetStrLen(const char *str)
{
    const char *p = str; // 记录起始地址

    // 利用'\0'查找字符串结束位置指针
    while(*str)
    {
        str++;
    }

    return str - p; // 相减后求得字符串长度
}

//-----------------------------------------------------------------------------------------------
// 名称: char *StrCpy(char *s1, const char *s2)
// 功能: 字符串复制函数
// 参数:
//         [char *s1] --- 目标字符串指针
//         [const char *s2] --- 源字符串指针
// 返回: [char *]  --- 指向目标字符串的指针
// 作者: 耿楠
// 日期: 2018年12月04日
// 注意: 该代码也可以通过调用MemCpy()函数实现，相关细节，请大家自行完善。
//-----------------------------------------------------------------------------------------------
char *StrCpy(char *s1, const char *s2)
{
    char *p = s1; // 保留原来指针

    // 复制字符串
    while((*s1++ = *s2++))
    {
        ;
    }

    return p; // 返回目标地址
}

//-----------------------------------------------------------------------------------------------
// 名称: void *MemCpy(void *s1, const void *s2, size_t count)
// 功能: 内存复制函数
// 算法: 将void*指针转换为char *指针，完成后续操作。
// 参数:
//         [void *s1] --- 目标内存首地址
//         [const void *s2] --- 源内存首地址
//         [size_t count] --- 复制的字节数
// 返回: [void *]  --- 指向目标字符串的指针
// 作者: 耿楠
// 日期: 2018年12月04日
// 注意: 该代码不完善，1是效率不高，2是当s1和s2指向的两个内存空间有重叠时会出错，
//          相关细节，请大家自行完善。
//-----------------------------------------------------------------------------------------------
void *MemCpy(void *s1, const void *s2, size_t count)
{
    // 声明临时指针，隐式类型转换
    char *tmp = s1;
    const char *s = s2;

    // 复制
    while (count--)
    {
        *tmp++ = *s++;
    }

    return s1; // 返回目标地址
}

//-----------------------------------------------------------------------------------------------
// 名称: int RshiftStrMem(char *str, int n)
// 功能: 利用内存操作实现循环右移位
// 算法: 申请一块与原字符串相同大小的内存，把原字符串的后n个字节拷贝到它的开始地址，
//          把原字符串的前(len-n)个字节拷贝到它的(开始地址+n)处。
// 参数:
//         [char *str] --- 要输出的字符串的指针
//         [int n] --- 移位的位数
// 返回: [int]  --- 函数运行状态，0表示正常，1表示错误
// 作者: 耿楠
// 日期: 2018年12月04日
//-----------------------------------------------------------------------------------------------
int RshiftStrMem(char *str, int n)
{
    int len;
    char *p;

    len = GetStrLen(str);
    if (len < n)
    {
        return 1; // 字符长度小于移位长度，无法移位
    }

    p = (char *)malloc(len); // 分配内存
    if (p == NULL)
    {
        return 1; // 内存分配失败，无法移位
    }

    // 把原字符串的后n个字节拷贝到p的开始地址
    MemCpy(p, str + len - n, n);
    // 把原字符串的前(len-n)个字节拷贝到p+n处
    MemCpy(p + n, str, len - n);
    // 复制到原字符串中
    MemCpy(str, p, len);

    free(p); // 释放内存

    str[len] = '\0'; // 添加终止字符

    return 0; // 程序运行正常，返回0
}

//-----------------------------------------------------------------------------------------------
// 名称: void ReverseStr(char *str, int left, int right)
// 功能: 对指定范围内的字符串进行逆序操作
// 算法: 分别从字符串的头和尾部向中间进发，依次交换头尾的值，直到在中间相遇。
// 参数:
//         [char *str] --- 要进行逆序的字符串指针
//         [int left] --- 起始位置
//         [int right] --- 结束位置
// 返回: [void]  --- 无
// 作者: 耿楠
// 日期: 2018年12月04日
//-----------------------------------------------------------------------------------------------
void ReverseStr(char *str, int left, int right)
{
    char tmp;
    while(left < right)
    {
        tmp = str[left];
        str[left++] = str[right];
        str[right--] = tmp;
    }
}

//-----------------------------------------------------------------------------------------------
// 名称: int RshiftStrRev(char *str, int n)
// 功能: 利用逆序操作实现循环右移位
// 算法: 比如字符串"abcdefg",要循环右移3位，那么这个字符串可以分为2部分：
//          前半部分："abcd" 和后半部分"efg"。
//          先把前半部分逆序变成 -> "dcba"
//          再把后半部分逆序变成 -> "gfe"
//          这时整体字符串应该是 "dcbagfe"
//          再对整个字符串逆序，结果 -> "efgabcd"。
//          从而完成循环右移。
//          该算法来自《编程珠玑》
// 参数:
//         [char *str] --- 要输出的字符串的指针
//         [int n] --- 移位的位数
// 返回: [int]  --- 函数运行状态，0表示正常，1表示错误
// 作者: 耿楠
// 日期: 2018年12月04日
//-----------------------------------------------------------------------------------------------
int RshiftStrRev(char *str, int n)
{
    int len = GetStrLen(str); // 字符串长度

    if (len < n)
    {
        return 1;  // 字符长度小于移位长度，无法移位
    }

    ReverseStr(str, 0, len - n - 1); // 前半部分逆序
    ReverseStr(str, len - n, len - 1); // 后半部分逆序
    ReverseStr(str, 0, len - 1); // 整个字符串逆序

    return 0; // 程序运行正常，返回0
}
